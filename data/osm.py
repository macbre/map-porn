#!/usr/bin/env python3
import bz2
import logging
import json
from posixpath import dirname
from tempfile import gettempdir
from dataclasses import dataclass
from os import path
from typing import Callable, Generator
from xml import sax
from xml.sax import handler, xmlreader

import requests

DIR = path.abspath(path.dirname(__file__))

# https://wiki.openstreetmap.org/wiki/Category:Tag_descriptions

# https://wiki.openstreetmap.org/wiki/Buses#Stops_and_bus_stations
# <tag k="highway" v="bus_stop"/>
# TAG_KEY = 'highway'
# TAG_VALUE = 'bus_stop'

# https://wiki.openstreetmap.org/wiki/Tag:aeroway%3Dhelipad
# <tag k="aeroway" v="helipad"/>
# TODO: handle <way> tags
# TAG_KEY = 'aeroway'
# TAG_VALUE = 'helipad'

# https://wiki.openstreetmap.org/wiki/Tag:amenity%3Dferry_terminal
# <tag k="amenity" v="ferry_terminal"/>
TAG_KEY = 'amenity'
TAG_VALUE = 'ferry_terminal'

# https://wiki.openstreetmap.org/wiki/Tag:barrier%3Dcattle_grid
TAG_KEY = 'barrier'
TAG_VALUE = 'cattle_grid'


def cache_osm_file():
    # https://download.geofabrik.de/europe/faroe-islands.html
    URL = 'https://download.geofabrik.de/europe/faroe-islands-latest.osm.bz2'
    LOCAL_FILE = path.join(DIR, 'osm-faroe-islands.xml.bz2')

    logger = logging.getLogger(name="fetch")

    if path.exists(LOCAL_FILE):
        logger.info(f'The cached OSM XML file exists at {LOCAL_FILE}')
        return LOCAL_FILE

    logger.info(f'The cached OSM XML not found at {LOCAL_FILE} -> fetching {URL} ...')

    resp = requests.get(URL, headers={'user-agent': 'osm.py'})
    resp.raise_for_status()

    logger.info(f'HTTP {resp.status_code}')

    with open(LOCAL_FILE, "wb") as f:
        f.write(resp.content)

    return LOCAL_FILE


class OSMHandler(handler.ContentHandler):
    def __init__(self, node_callback: callable = None) -> None:
        """
        Can be optionally provided with a node callback
        that will be called at the end of processing each <node> tag.
        """
        self._reset()
        self.logger = logging.getLogger(name=self.__class__.__name__)

        # here we'll keep the references to <node> tags without any children
        # they're later referenced by <way> tags
        self.nodes_references: dict[str, Node] = {}
        self.nodes_counter = 0

        # this will be called on each <node> tag along with its tags
        # <way> tags will also call it with the first references <node> tag
        self.node_callback = node_callback

    def _reset(self, current_element: str = None):
        self.current_element = current_element
        self.attrs = {}
        self.tags = []

    def startElement(self, name: str, attrs: xmlreader.AttributesImpl):
        if name == 'osm':
            # <osm version="0.6" generator="osmium/1.14.0">
            self.logger.info(f'OSM XML starts here, generated by {attrs.get("generator", "n/a")}')

        # https://wiki.openstreetmap.org/wiki/Node#Structure
        elif name == 'node':
            # <node id="29023814" version="5" timestamp="2022-12-08T01:56:54Z" lat="61.5557547" lon="-6.8145764">
            self._reset(current_element='node')
            self.nodes_counter = self.nodes_counter + 1

            self.attrs = {
                'id': attrs['id'],
                'lat': attrs['lat'],
                'lon': attrs['lon'],
            }

        elif name == 'tag' and self.current_element in ['node', 'way']:
            # append tags as a tuple
            # <tag k="place" v="town"/>
            # e.g. ('highway', 'traffic_signals'), ('traffic_signals', 'traffic_lights')
            self.tags.append((attrs['k'], attrs['v']))

        elif name == 'way':
            """
            <node id="374178126" version="5" timestamp="2019-10-05T00:55:31Z" lat="62.0112091" lon="-6.7721186"/>
            (...)
            <way id="4965566" version="8" timestamp="2019-10-05T00:52:15Z">
                <nd ref="374178126"/>
                <nd ref="4321355681"/>
                <tag k="highway" v="residential"/>
                <tag k="name" v="Sverrisgøta"/>
                <tag k="oneway" v="yes"/>
                <tag k="surface" v="asphalt"/>
            </way>
            """
            self._reset(current_element='way')

            # now wait for the first <nd ref="374178126"/> tag

        elif name == 'nd' and self.current_element == 'way':
            if not self.attrs.keys():
                # this is the first <nd> child of the <way> tag
                # get the referenced node
                if referenced_node := self.nodes_references.get( attrs['ref'] ):
                    self.logger.debug(f'Found referenced node for #{attrs["ref"]}')

                    self.attrs = {
                        'id': attrs['ref'],
                        'lat': referenced_node.lat,
                        'lon': referenced_node.lon,
                    }

                else:
                    self.logger.debug(f'Cannot find referenced node for #{attrs["ref"]}')


    def endElement(self, name: str):
        """
        Call node_callback for each <node> and <way> tag
        """
        if name == 'node':
            if self.tags:
                self.logger.debug(f'{name} ({self.attrs}): {self.tags}')

                if self.node_callback:
                    self.node_callback(self.attrs, self.tags)
            else:
                # register a node reference
                # as this <node> does not have any tags defined, it will be highly likely referenced by <way>
                self.logger.debug(f'{name} #{self.attrs["id"]} reference stored')

                self.nodes_references[ self.attrs['id'] ] = Node(
                    lat=self.attrs['lat'],
                    lon=self.attrs['lon'],
                    tags=[]
                )

            self._reset()

        elif name == 'way':
            if self.tags:
                self.logger.debug(f'{name} ({self.attrs}): {self.tags}')

                if self.node_callback:
                    self.node_callback(self.attrs, self.tags)

                self._reset()

    def endDocument(self):
        self.logger.info(f'Parsed OSM XML file with {self.nodes_counter} node(s) including')


def iterate_xml(xml_file, node_callback: callable):
    """
    Given a path to the local bz2-compressed OSM XML file parse it.
    """
    logger = logging.getLogger(name="xml")
    logger.info(f'Parsing OSM XML from {xml_file}')

    with bz2.open(xml_file) as f:
        # https://docs.python.org/3/library/xml.sax.reader.html
        reader = sax.make_parser(('xml.sax.xmlreader.IncrementalParser'))
        reader.setContentHandler(OSMHandler(node_callback))
        reader.parse(f)


@dataclass
class Node:
    lat: str
    lon: str
    tags: list[tuple[str, str]]


def main():
    logger = logging.getLogger(name="osm")
    logger.info(f'Looking for "{TAG_KEY}" = "{TAG_VALUE}" ...')

    nodes: list[Node] = []

    def node_callback(node_attrs: dict[str, str], node_tags: list[tuple]):
        """
        This will be called for each parsed <node> tag
        """
        # <tag k="bus" v="yes"/>
        # <tag k="highway" v="bus_stop"/>
        matches = [
            (TAG_KEY, TAG_VALUE),
            # ('bus', 'yes'),
        ]

        for (key, value) in node_tags:
            if (key, value) in matches:
                logger.info(f'Matching node found: {node_attrs} ({node_tags}')

                nodes.append(Node(
                    lat=node_attrs['lat'],
                    lon=node_attrs['lon'],
                    tags=node_tags
                ))

    local_file = cache_osm_file()
    iterate_xml(local_file, node_callback)

    # write a GeoJSON file
    geojson_file = path.join(DIR, '..', 'geojson', f'osm-{TAG_KEY}-{TAG_VALUE}.json')
    logger.info(f'Writing {len(nodes)} node(s) GeoJSON to {geojson_file} ...')

    with open(geojson_file, 'wt') as f:
        # https://geojson.org/ // https://geojson.io/
        features = [
            {
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": [float(node.lon), float(node.lat)]
                },
                "properties": {
                    # e.g. ('name', 'Jóannesar Paturssonar gøta')
                    key: value
                    for (key, value) in node.tags 
                }
            }
            for node in nodes
        ]

        # f.write('const points = ')
        json.dump(
            {
                'type': 'FeatureCollection',
                'features': features,
            },
            fp=f,
            indent=True
        )


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
