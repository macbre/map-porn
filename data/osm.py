#!/usr/bin/env python3
import bz2
import logging
import json
from posixpath import dirname
from tempfile import gettempdir
from dataclasses import dataclass
from os import path
from typing import Callable, Generator
from xml import sax
from xml.sax import handler, xmlreader

import requests

DIR = path.abspath(path.dirname(__file__))

# https://wiki.openstreetmap.org/wiki/Category:Tag_descriptions

# https://wiki.openstreetmap.org/wiki/Buses#Stops_and_bus_stations
# <tag k="highway" v="bus_stop"/>
# TAG_KEY = 'highway'
# TAG_VALUE = 'bus_stop'

# https://wiki.openstreetmap.org/wiki/Tag:aeroway%3Dhelipad
# <tag k="aeroway" v="helipad"/>
# TODO: handle <way> tags
# TAG_KEY = 'aeroway'
# TAG_VALUE = 'helipad'

# https://wiki.openstreetmap.org/wiki/Tag:amenity%3Dferry_terminal
# <tag k="amenity" v="ferry_terminal"/>
TAG_KEY = 'amenity'
TAG_VALUE = 'ferry_terminal'

def cache_osm_file():
    # https://download.geofabrik.de/europe/faroe-islands.html
    URL = 'https://download.geofabrik.de/europe/faroe-islands-latest.osm.bz2'
    LOCAL_FILE = path.join(DIR, 'osm-faroe-islands.xml.bz2')

    logger = logging.getLogger(name="fetch")

    if path.exists(LOCAL_FILE):
        logger.info(f'The cached OSM XML file exists at {LOCAL_FILE}')
        return LOCAL_FILE

    logger.info(f'The cached OSM XML not found at {LOCAL_FILE} -> fetching {URL} ...')

    resp = requests.get(URL, headers={'user-agent': 'osm.py'})
    resp.raise_for_status()

    logger.info(f'HTTP {resp.status_code}')

    with open(LOCAL_FILE, "wb") as f:
        f.write(resp.content)

    return LOCAL_FILE


class OSMHandler(handler.ContentHandler):
    def __init__(self, node_callback: callable = None) -> None:
        """
        Can be optionally provided with a node callback
        that will be called at the end of processing each <node> tag.
        """
        self._reset()
        self.logger = logging.getLogger(name=self.__class__.__name__)

        self.nodes_counter = 0
        self.node_callback = node_callback

    def _reset(self, current_element: str = None):
        self.current_element = current_element
        self.attrs = {}
        self.tags = []

    def startElement(self, name: str, attrs: xmlreader.AttributesImpl):
        if name == 'osm':
            # <osm version="0.6" generator="osmium/1.14.0">
            self.logger.info(f'OSM XML starts here, generated by {attrs.get("generator", "n/a")}')

        # https://wiki.openstreetmap.org/wiki/Node#Structure
        elif name == 'node':
            # <node id="29023814" version="5" timestamp="2022-12-08T01:56:54Z" lat="61.5557547" lon="-6.8145764">
            self._reset(current_element='node')
            self.nodes_counter = self.nodes_counter + 1

            self.attrs = {
                'id': attrs['id'],
                'lat': attrs['lat'],
                'lon': attrs['lon'],
            }
        elif name == 'tag' and self.current_element == 'node':
            # append tags as a tuple
            # <tag k="place" v="town"/>
            # e.g. ('highway', 'traffic_signals'), ('traffic_signals', 'traffic_lights')
            self.tags.append((attrs['k'], attrs['v']))

    def endElement(self, name: str):
        if name == 'node':
            if self.tags:
                self.logger.debug(f'{name} ({self.attrs}): {self.tags}')

                if self.node_callback:
                    self.node_callback(self.attrs, self.tags)

            self._reset()

    def endDocument(self):
        self.logger.info(f'Parsed OSM XML file with {self.nodes_counter} node(s)')


def iterate_xml(xml_file, node_callback: callable):
    """
    Given a path to the local bz2-compressed OSM XML file parse it.
    """
    logger = logging.getLogger(name="xml")
    logger.info(f'Parsing OSM XML from {xml_file}')

    with bz2.open(xml_file) as f:
        # https://docs.python.org/3/library/xml.sax.reader.html
        reader = sax.make_parser(('xml.sax.xmlreader.IncrementalParser'))
        reader.setContentHandler(OSMHandler(node_callback))
        reader.parse(f)


@dataclass
class Node:
    lat: str
    lon: str
    tags: list[tuple[str, str]]


def main():
    logger = logging.getLogger(name="osm")
    logger.info(f'Looking for "{TAG_KEY}" = "{TAG_VALUE}" ...')

    nodes: list[Node] = []

    def node_callback(node_attrs: dict[str, str], node_tags: list[tuple]):
        """
        This will be called for each parsed <node> tag
        """
        # <tag k="bus" v="yes"/>
        # <tag k="highway" v="bus_stop"/>
        matches = [
            (TAG_KEY, TAG_VALUE),
            # ('bus', 'yes'),
        ]

        for (key, value) in node_tags:
            if (key, value) in matches:
                logger.info(f'Matching node found: {node_attrs} ({node_tags}')

                nodes.append(Node(
                    lat=node_attrs['lat'],
                    lon=node_attrs['lon'],
                    tags=node_tags
                ))

    local_file = cache_osm_file()
    iterate_xml(local_file, node_callback)

    # write a GeoJSON file
    geojson_file = path.join(DIR, f'{TAG_KEY}-{TAG_VALUE}.json')
    logger.info(f'Writing {len(nodes)} node(s) GeoJSON to {geojson_file} ...')

    with open(geojson_file, 'wt') as f:
        # https://geojson.org/ // https://geojson.io/
        features = [
            {
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": [float(node.lon), float(node.lat)]
                },
                "properties": {
                    # e.g. ('name', 'Jóannesar Paturssonar gøta')
                    key: value
                    for (key, value) in node.tags 
                }
            }
            for node in nodes
        ]

        # f.write('const points = ')
        json.dump(
            {
                'type': 'FeatureCollection',
                'features': features,
            },
            fp=f,
            indent=True
        )


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
